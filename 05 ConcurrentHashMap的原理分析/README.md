### ConcurrentHashMap1.8中是基于什么机制来保证线程安全性的
- 通过Node + CAS + Synchronized来保证线程安全性

### ConcurrentHashMap通过get方法获取数据的时候，是否需要通过加锁来保证数据的可见性？为什么？
- 不需要，因为Node是volatile修饰的，最新的修改的值对其他线程都是可见的
### ConcurrentHashMap1.7和ConcurrentHashMap1.8有哪些区别？
- 1.8中取消了segment分段锁的设计,通过锁住node来实现减小锁粒度
- 1.8中增加了红黑树的设计
- 1.8中设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize
### ConcurrentHashMap1.8为什么要引入红黑树？
- 当链表过长的时候，会导致遍历花费更长的时间O（N）,而使用红黑树的时间复杂度为: O(lgn)，提升了效率。
- 其中，链表长度超过8的时候来红黑树，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以知道链表中元素个数为8时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了8，是根据概率统计而选择的。